package kimple.clr;

import kimple.ast.*;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

public class KimpleClrGenerator {
    private final ProgramNode program;
    private final StringBuilder code = new StringBuilder();
    private int labelCounter = 0;
    private int localIndexCounter = 0;
    private final Map<String, String> symbolTable = new HashMap<>();
    private final Map<String, Integer> localIndices = new HashMap<>();
    private final Map<String, String> functionReturnTypes = new HashMap<>();
    private final Deque<String> funcStack = new LinkedList<>();
    private final Map<String, String> paramTable = new HashMap<>();
    private final Map<String, Integer> paramIndices = new HashMap<>();
    private boolean hasExplicitReturn = false;

    public KimpleClrGenerator(ProgramNode program) {
        this.program = program;
    }

    public void generate() throws IOException {
        code.append("// Generated by Kimple CLR Generator\n");
        code.append(".assembly extern mscorlib { .publickeytoken = (B7 7A 5C 56 19 34 E0 89) .ver 4:0:0:0 }\n");
        code.append(".assembly program { .hash algorithm 0x00008004 .ver 0:0:0:0 }\n");
        code.append(".module program.exe\n");
        code.append(".class private auto ansi beforefieldinit Program extends [mscorlib]System.Object {\n");

        List<FuncDeclNode> funcDecls = new ArrayList<>();
        List<ASTNode> others = new ArrayList<>();
        for (ASTNode top : program.getTopLevel()) {
            if (top instanceof FuncDeclNode f) funcDecls.add(f);
            else others.add(top);
        }

        for (FuncDeclNode f : funcDecls) {
            genFunction(f);
        }

        code.append("  .method private hidebysig static void Main(string[] args) cil managed {\n");
        code.append("    .entrypoint\n");

        symbolTable.clear();
        localIndices.clear();
        paramTable.clear();
        paramIndices.clear();
        localIndexCounter = 0;

        collectLocalsFrom(others);
        generateLocals();

        for (ASTNode o : others) {
            if (o instanceof StatementNode s) genStatement(s);
        }

        boolean hasMain = funcDecls.stream().anyMatch(fd -> "main".equals(fd.getName()));
        if (hasMain) {
            genFuncCall(new FuncCallExprNode("main", new ArrayList<>(), 0));
        }

        code.append("    ret\n");
        code.append("  }\n");
        code.append("}\n");

        String outputPath = "out/production/lab2/kimple/program.il";
        try (FileWriter writer = new FileWriter(outputPath)) {
            writer.write(code.toString());
        }
        System.out.println("\nCLR код записаний у: " + outputPath);
    }

    private void processDeclarations(List<? extends ASTNode> nodes) {
        for (ASTNode node : nodes) {
            if (node instanceof VarDeclNode v) {
                String clrType = mapType(v.getType());
                if (paramTable.containsKey(v.getName())) continue;
                symbolTable.put(v.getName(), clrType);
                localIndices.put(v.getName(), localIndexCounter++);
            }
        }
    }

    private void genFuncCall(FuncCallExprNode c) {
        List<String> paramTypes = new ArrayList<>();
        for (ExpressionNode arg : c.getArgs()) {
            String t = genExpression(arg);
            paramTypes.add(t);
        }

        String full = funcFullName(c.getName());
        String retType = getFunctionReturnType(full);
        code.append("    call " + retType + " Program::" + full + "(");
        code.append(String.join(", ", paramTypes));
        code.append(")\n");
    }

    private void generateLocals() {
        code.append("    .locals init (");
        List<String> localsList = new ArrayList<>();
        for (Map.Entry<String, String> entry : symbolTable.entrySet()) {
            localsList.add("[" + localIndices.get(entry.getKey()) + "] " + entry.getValue() + " " + entry.getKey());
        }
        code.append(String.join(", ", localsList));
        code.append(")\n");
    }

    private void genFunction(FuncDeclNode fn) {
        String fullName = funcFullName(fn.getName());
        String returnType = mapType(fn.getReturnType());
        functionReturnTypes.put(fullName, returnType);

        funcStack.push(fn.getName());

        code.append("  .method private hidebysig static " + returnType + " " + fullName + "(");
        List<String> params = new ArrayList<>();
        for (int i = 0; i < fn.getParamNames().size(); i++) {
            params.add(mapType(fn.getParamTypes().get(i)) + " " + fn.getParamNames().get(i));
        }
        code.append(String.join(", ", params));
        code.append(") cil managed {\n");

        symbolTable.clear();
        localIndices.clear();
        paramTable.clear();
        paramIndices.clear();
        localIndexCounter = 0;

        for (int i = 0; i < fn.getParamNames().size(); i++) {
            String name = fn.getParamNames().get(i);
            String type = mapType(fn.getParamTypes().get(i));
            paramTable.put(name, type);
            paramIndices.put(name, i);
        }

        collectLocalsFrom(fn.getBody().getStatements());
        generateLocals();

        hasExplicitReturn = false;
        genBlock(fn.getBody());
        if (!hasExplicitReturn) code.append("    ret\n");
        code.append("  }\n");

        for (FuncDeclNode nested : fn.getNested()) genFunction(nested);
        funcStack.pop();
    }

    private void genStatement(StatementNode s) {
        if (s instanceof VarDeclNode v) genVarDecl(v);
        else if (s instanceof AssignmentNode a) genAssignment(a);
        else if (s instanceof InputNode i) genInput(i);
        else if (s instanceof OutputNode o) genOutput(o);
        else if (s instanceof ReturnNode r) genReturn(r);
        else if (s instanceof IfNode i) genIf(i);
        else if (s instanceof WhileNode w) genWhile(w);
        else if (s instanceof ForNode f) genFor(f);
        else if (s instanceof FuncCallStmtNode fc) {
            genFuncCall(fc.getCall());
            code.append("    pop\n");
        }
        else if (s instanceof BlockNode b) genBlock(b);
        else if (s instanceof FuncDeclNode fd) {
            genFunction(fd);
        }
        else throw new RuntimeException("Unsupported statement: " + s);
    }

    private void genVarDecl(VarDeclNode v) {
        if (v.getInit() != null) {
            genAssignment(new AssignmentNode(v.getName(), v.getInit(), v.getLine()));
        }
    }

    private void genAssignment(AssignmentNode a) {
        genExpression(a.getExpr());
        String name = a.getName();
        if (paramIndices.containsKey(name)) {
            int idx = paramIndices.get(name);
            if (idx >= 0 && idx <= 3) code.append("    starg " + idx + "\n");
            else code.append("    starg.s " + idx + "\n");
        } else if (localIndices.containsKey(name)) {
            int idx = localIndices.get(name);
            if (idx >= 0 && idx <= 3) code.append("    stloc." + idx + "\n");
            else code.append("    stloc " + idx + "\n");
        } else {
            throw new RuntimeException("Unknown assignment target: " + name);
        }
    }

    private void genInput(InputNode in) {
        code.append("    call string [mscorlib]System.Console::ReadLine()\n");
        String type = symbolTable.get(in.getTargetName());
        if (type.equals("int32")) {
            code.append("    call int32 [mscorlib]System.Int32::Parse(string)\n");
        } else if (type.equals("float64")) {
            code.append("    call float64 [mscorlib]System.Double::Parse(string)\n");
        }
        code.append("    stloc " + localIndices.get(in.getTargetName()) + "\n");
    }

    private void genOutput(OutputNode o) {
        for (ExpressionNode e : o.getArgs()) {
            String type;
            if (e instanceof LiteralNode l && l.getType().equals("String")) {
                code.append("    ldstr " + escapeStringLiteral(l.getValue()) + "\n");
                type = "string";
            } else {
                type = genExpression(e);
            }
            code.append("    call void [mscorlib]System.Console::Write(" + type + ")\n");
        }
        code.append("    call void [mscorlib]System.Console::WriteLine()\n");
    }

    private String escapeStringLiteral(String s) {
        return "\"" + s.replace("\\", "\\\\").replace("\"", "\\\"") + "\"";
    }

    private String genExpressionType(ExpressionNode e) {
        return mapType(genExpression(e));
    }

    private void genReturn(ReturnNode r) {
        if (r.getExpr() != null) genExpression(r.getExpr());
        code.append("    ret\n");
        hasExplicitReturn = true;
    }

    private void genBlock(BlockNode b) {
        for (StatementNode s : b.getStatements()) {
            genStatement(s);
        }
    }

    private void genIf(IfNode n) {
        genExpression(n.getCond());
        if (n.getElseBlock() == null) {
            String endLabel = newLabel();
            code.append("    brfalse " + endLabel + "\n");
            genBlock(n.getThenBlock());
            code.append(endLabel + ":\n");
        } else {
            String elseLabel = newLabel();
            String endLabel  = newLabel();
            code.append("    brfalse " + elseLabel + "\n");
            genBlock(n.getThenBlock());
            code.append("    br " + endLabel + "\n");
            code.append(elseLabel + ":\n");
            genBlock(n.getElseBlock());
            code.append(endLabel + ":\n");
        }
    }

    private void genWhile(WhileNode n) {
        String startLabel = newLabel();
        String endLabel = newLabel();

        code.append(startLabel + ":\n");
        genExpression(n.getCond());
        code.append("    brfalse " + endLabel + "\n");
        genBlock(n.getBody());
        code.append("    br " + startLabel + "\n");
        code.append(endLabel + ":\n");
    }

    private void genFor(ForNode f) {
        String varName = f.getVarName();
        localIndices.put(varName, localIndexCounter++);
        genExpression(f.getStartExpr());
        code.append("    stloc " + localIndices.get(varName) + "\n");

        String loopLabel = newLabel();
        String endLabel = newLabel();

        code.append(loopLabel + ":\n");
        code.append("    ldloc " + localIndices.get(varName) + "\n");
        genExpression(f.getEndExpr());
        code.append("    cgt\n");
        code.append("    brtrue " + endLabel + "\n");
        genBlock(f.getBody());
        code.append("    ldloc " + localIndices.get(varName) + "\n");
        code.append("    ldc.i4 1\n");
        code.append("    add\n");
        code.append("    stloc " + localIndices.get(varName) + "\n");
        code.append("    br " + loopLabel + "\n");
        code.append(endLabel + ":\n");
    }

    private String genExpression(ExpressionNode e) {
        if (e instanceof LiteralNode l) {
            switch (l.getType()) {
                case "Int" -> {
                    code.append("    ldc.i4 " + l.getValue() + "\n");
                    return "int32";
                }
                case "Double" -> {
                    if (l.getValue().equalsIgnoreCase("inf")) {
                        code.append("    ldc.r8 1E300\n");
                        code.append("    ldc.r8 1E300\n");
                        code.append("    mul\n");
                        return "float64";
                    } else if (l.getValue().equalsIgnoreCase("-inf")) {
                        code.append("    ldc.r8 1E300\n");
                        code.append("    ldc.r8 1E300\n");
                        code.append("    mul\n");
                        code.append("    ldc.r8 -1.0\n");
                        code.append("    mul\n");
                        return "float64";
                    } else {
                        code.append("    ldc.r8 " + l.getValue() + "\n");
                        return "float64";
                    }
                }
                case "String" -> {
                    code.append("    ldstr " + l.getValue() + "\n");
                    return "string";
                }
                case "Boolean" -> {
                    code.append("    ldc.i4." + (l.getValue().equalsIgnoreCase("true") ? "1" : "0") + "\n");
                    return "int32";
                }
            }
        } else if (e instanceof IdentNode id) {
            String name = id.getName();
            if (paramIndices.containsKey(name)) {
                int idx = paramIndices.get(name);
                code.append(idx <= 3 ? "    ldarg." + idx + "\n" : "    ldarg " + idx + "\n");
                return paramTable.get(name);
            } else if (localIndices.containsKey(name)) {
                int idx = localIndices.get(name);
                code.append(idx <= 3 ? "    ldloc." + idx + "\n" : "    ldloc " + idx + "\n");
                return symbolTable.get(name);
            } else {
                throw new RuntimeException("Unknown identifier: " + name);
            }
        } else if (e instanceof BinaryOpNode b) {
            String lt = genExpression(b.getLeft());
            String rt = genExpression(b.getRight());

            boolean isFloat = lt.equals("float64") || rt.equals("float64");
            if (isFloat) {
                if (lt.equals("int32")) code.append("    conv.r8\n");
                if (rt.equals("int32")) code.append("    conv.r8\n");
            }

            if (b.getOp().equals("^")) {
                if (lt.equals("int32")) code.append("    conv.r8\n");
                if (rt.equals("int32")) code.append("    conv.r8\n");
                code.append("    call float64 [mscorlib]System.Math::Pow(float64, float64)\n");
                return "float64";
            }

            switch (b.getOp()) {
                case "+" -> code.append("    add\n");
                case "-" -> code.append("    sub\n");
                case "*" -> code.append("    mul\n");
                case "/" -> code.append("    div\n");
                case "%" -> code.append("    rem\n");
                case "==" -> code.append("    ceq\n");
                case "!=" -> code.append("    ceq\n    ldc.i4.0\n    ceq\n");
                case "<" -> code.append("    clt\n");
                case ">" -> code.append("    cgt\n");
                case "<=" -> code.append("    cgt\n    ldc.i4.0\n    ceq\n");
                case ">=" -> code.append("    clt\n    ldc.i4.0\n    ceq\n");
                case "&&" -> code.append("    and\n");
                case "||" -> code.append("    or\n");
                default -> throw new RuntimeException("Unknown op: " + b.getOp());
            }
            return isFloat ? "float64" : "int32";
        } else if (e instanceof UnaryOpNode u) {
            String type = genExpression(u.getExpr());
            if (u.getOp().equals("-")) {
                code.append("    neg\n");
            } else if (u.getOp().equals("!")) {
                code.append("    ldc.i4.0\n    ceq\n");
            }
            return type;
        } else if (e instanceof FuncCallExprNode fc) {
            List<String> paramTypes = new ArrayList<>();
            for (ExpressionNode arg : fc.getArgs()) {
                String t = genExpression(arg); // emit loads
                paramTypes.add(t);
            }
            String full = funcFullName(fc.getName());
            String retType = getFunctionReturnType(full);

            code.append("    call " + retType + " Program::" + full + "(" + String.join(", ", paramTypes) + ")\n");
            return retType;
        } else if (e instanceof CastNode c) {
            genExpression(c.getTarget());
            switch (c.getToType()) {
                case "Int" -> code.append("    conv.i4\n");
                case "Double" -> code.append("    conv.r8\n");
                case "String" -> code.append("    call string [mscorlib]System.Convert::ToString(object)\n");
                case "Boolean" -> code.append("    conv.i4\n");
            }
            return mapType(c.getToType());
        }
        throw new RuntimeException("Unsupported expression: " + e.getClass());
    }

    private void collectLocalsFrom(List<? extends ASTNode> nodes) {
        for (ASTNode node : nodes) {
            if (node instanceof VarDeclNode v) {
                String name = v.getName();
                if (!symbolTable.containsKey(name)) {
                    String clrType = mapType(v.getType());
                    symbolTable.put(name, clrType);
                    localIndices.put(name, localIndexCounter++);
                }
            } else if (node instanceof ForNode f) {
                // змінна циклу
                String varName = f.getVarName();
                if (!symbolTable.containsKey(varName)) {
                    symbolTable.put(varName, "int32");
                    localIndices.put(varName, localIndexCounter++);
                }
                // рекурсивно збираємо з тіла циклу
                collectLocalsFrom(f.getBody().getStatements());
            } else if (node instanceof WhileNode w) {
                collectLocalsFrom(w.getBody().getStatements());
            } else if (node instanceof IfNode i) {
                collectLocalsFrom(i.getThenBlock().getStatements());
                if (i.getElseBlock() != null) {
                    collectLocalsFrom(i.getElseBlock().getStatements());
                }
            } else if (node instanceof BlockNode b) {
                collectLocalsFrom(b.getStatements());
            }
        }
    }

    private String getFunctionReturnType(String fullName) {
        String type = functionReturnTypes.get(fullName);
        if (type == null) throw new RuntimeException("Unknown function: " + fullName);
        return type;
    }

    private String funcFullName(String name) {
        if (funcStack.isEmpty()) return name;
        return String.join("$", funcStack) + "$" + name;
    }

    private String mapType(String t) {
        return switch (t.toLowerCase()) {
            case "int" -> "int32";
            case "double" -> "float64";
            case "string" -> "string";
            case "boolean" -> "int32";
            case "unit", "void" -> "void";
            default -> "object";
        };
    }

    private String newLabel() {
        return "m" + (labelCounter++);
    }
}